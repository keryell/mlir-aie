<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'AIE' Dialect

This is a dialect for describing netlists of AIE components in a
Versal device.  It focuses on representing logical stream connections
between cores and DMAs, along with the implementation of those logical
connections in the various switch components.  In the dialect, a
switch is referred to as `switchbox` to avoid confusion with the
`switch` keyword in C/C++.


[TOC]

## Operation definition

### `AIE.amsel` (::xilinx::AIE::AMSelOp)

Declare an arbiter of a switchbox with a master select value (arbiter + msel)


Syntax:

```
operation ::= `AIE.amsel` `<` $arbiterID `>` `(` $msel `)` attr-dict
```

A combination of arbiter ID and master select (msel) value.
This op is used as a pointer to select the arbiter for routing a packet-switched flow

Example:
```
    %a0_0 = AIE.amsel<5>(3)
    %m1 = AIE.masterset("East" : 0, %a0_0 )
    AIE.packetrules("South" : 0) {
      AIE.rule(0x1F, 0x10, %a0_0)
    }
```
This code associates arbiter 5 with msel=3.  A packet-switched connection is made routing
traffic from the South:0 port to the East:0 port using this arbiter.
There are 6 arbiters per switchbox and 4 possible master select values.
See also [MasterSetOp](#aiemasterset-aiemastersetop),
[PacketRulesOp](#aiepacketrules-aiepacketrulesop), and
[PacketRuleOp](#aierule-aiepacketruleop) for more information.

Traits: HasParent<SwitchboxOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `arbiterID` | ::mlir::IntegerAttr | 8-bit signless integer attribute whose minimum value is 0 whose maximum value is 5
| `msel` | ::mlir::IntegerAttr | 8-bit signless integer attribute whose minimum value is 0 whose maximum value is 3

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.buffer` (::xilinx::AIE::BufferOp)

Declare a buffer


Syntax:

```
operation ::= `AIE.buffer` `(` $tile `)` attr-dict `:` type($buffer)
```

This operation instantiates a buffer that belongs to a Memory Module of a tile.

Example:
```
  %tile33 = AIE.tile(3, 3)
  %buf = AIE.buffer(%tile33) : memref<256xi64>
```
This operation represents a buffer in tile (3, 3) of 256 elements, each a 64-bit integer.

Interfaces: TileElement

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
| `buffer` | memref of any type values

### `AIE.connect` (::xilinx::AIE::ConnectOp)

A circuit-switched connection inside a switchbox


Syntax:

```
operation ::= `AIE.connect` `<` $sourceBundle `:` $sourceChannel `,` $destBundle `:` $destChannel `>` attr-dict
```

This operation represents a programmed circuit-switched connection in a stream switch.
It associates a source bundle and source channel with a destination bundle and a destination channel.
This operation must exist within an `aie.switchbox` or `aie.shimswitchbox` operation.
All of the `aie.connect` operations in a switchbox must have a different destinations.
All of the `aie.connect` operations must also have a destination which is different from all
of the `aie.masterset` operations in the same switchbox.

Example:
```
%tile = aie.tile(1, 1)
aie.switchbox(%tile) {
  aie.connect<"West" : 0, "Core" : 1>
}
```

Traits: HasParent<SwitchboxOp, ShimMuxOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

### `AIE.core` (::xilinx::AIE::CoreOp)

Declare a core module


Syntax:

```
operation ::= `AIE.core` `(` $tile `)` regions attr-dict
```

This operation represents an AIEngine processor core belonging to a tile.
The region of a CoreOp contains code that gets run on the AIE core.  This code will
typically be outlined into the LLVM dialect, eventually resulting in a binary file
for each core.  The name of this file can be be specified using the `elf_file`
attribute.

This op has an optional `stackSize` attribute, to control the amount of memory (in bytes)
reserved for the stack.  The default value is 1024.  The stack (and other data allocations)
are always stored in the local core memory, to avoid conflicts with static data allocations
in other cores.

Examples:
```
%tile = aie.tile(1, 1)
%lock11_8 = AIE.lock(%tile, 8)
aie.core(%tile) {
  AIE.useLock(%lock11_8, "Acquire", 1)
  AIE.useLock(%lock11_8, "Release", 0)
  AIE.end
}
```
```
%tile = AIE.tile(3, 3)
AIE.core(%tile) {
  AIE.end
} { stackSize = 2048 : i32, elf_file = "core_33.elf" }
```

Interfaces: FlowEndPoint, TileElement

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `stackSize` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.dmaBd` (::xilinx::AIE::DMABDOp)

Declare a dma block descriptor op


Syntax:

```
operation ::= `AIE.dmaBd` `(` `<` $buffer  `:` type($buffer) `,` $offset `,` $len `>` `,` $AB `)` attr-dict
```

This operation describes a block descriptor for DMA operations. In particular, it specifies
what buffer addresss to use, the transfer length, and the buffer type (A or B).

This operation must be used in an MLIR block that lives inside a MemOp's region.
The block descriptor specifies what lock to use and the buffer configuration.

Example:
```
  // this defines a BD that uses lock %lck0 and buffer %buf0
  ^bd5:
    AIE.useLock(%lck, "Acquire", 0)
    AIE.dmaBd(<$buf0 : memref<512xi32>, 0, 512>, 1)
    AIE.useLock(%lck, "Release", 1)
    br ^bd6 // point to the next Block, which is also a different Block Descriptor

  ...

  // this defines a BD that does not use any lock
  ^bd8:
    AIE.dmaBd(<$buf1 : memref<64xi32>, 0, 64>, 0)
```
A DMA channel in a Memory Module can process one block descriptor after another by chaining them.
There are 16 block descriptors per Memory Module. They are shared by four DMA channels.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `offset` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `len` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `AB` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0 whose maximum value is 1

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `buffer` | memref of any type values

### `AIE.dmaBdPacket` (::xilinx::AIE::DMABDPACKETOp)

Enable packet headers for a dma block descriptor


Syntax:

```
operation ::= `AIE.dmaBdPacket` `(` $packet_type `,` $packet_id `)` attr-dict
```

This operation enables packet headers for a block descriptor for DMA operations. In particular, it specifies
the packet type (3-bits) and packet ID (5-bits).

This operation must be used in an MLIR block that lives inside a MemOp's region, and before AIE.dmaBd.
The block descriptor specifies what lock to use and the buffer configuration.

Example:
```
  // this defines a BD that uses lock %lck0 and buffer %buf0
  ^bd5:
    AIE.useLock(%lck, "Acquire", 0)
    AIE.dmaBdPacket(0x4, 0xD)
    AIE.dmaBd(<$buf0 : memref<512xi32>, 0, 512>, 1)
    AIE.useLock(%lck, "Release", 1)
    br ^bd6 // point to the next Block, which is also a different Block Descriptor

```


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `packet_type` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `packet_id` | ::mlir::IntegerAttr | 32-bit signless integer attribute

### `AIE.dmaStart` (::xilinx::AIE::DMAStartOp)

An op to start DMA


Syntax:

```
operation ::= `AIE.dmaStart` `(` $channelDir `,` $channelIndex `,` $dest `,` $chain `)` attr-dict
```

This operation declares a DMA channel to be used for data transfer. It usually exists inside
either a MemOp (representing a TileDMA), a MemTileDMAOp (representing a DMA in a MemTile),
or in a ShimDMAOp (representing a ShimDMA).
A channel is defined by a direction (i.e., MM2S or S2MM) and an index.

Example:
```
    AIE.dmaStart("MM2S", 0, ^bd0, ^end)
  ^bd0:
    AIE.useLock(%lock0, "Acquire", 0)
    AIE.dmaBd(<%buffer : memref<16 x f32>, 0, 16>, 0)
    AIE.useLock(%lock0, "Release", 1)
    br ^bd0
  ^end:
    AIE.end
```

Conceptually, the AIE.dmaStart operation is a terminator that either passes
control to a basic block containing DMA operations (through its first successor)
or to a basic block for another dmaStart, to an AIE.end operation.

Traits: HasParent<MemOp, MemTileDMAOp, func::FuncOp, ShimDMAOp>, Terminator

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `channelDir` | xilinx::AIE::DMAChannelDirAttr | DMA Channel direction
| `channelIndex` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Results:

| Result | Description |
| :----: | ----------- |
| `valid` | 1-bit signless integer

#### Successors:

| Successor | Description |
| :-------: | ----------- |
| `dest` | any successor
| `chain` | any successor

### `AIE.debug` (::xilinx::AIE::DebugOp)

Capture a value for debugging


Syntax:

```
operation ::= `AIE.debug` `(` $arg `:` type($arg) `)` attr-dict
```

Output the given value for debugging.  This is primarily used for simulation.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

### `AIE.device` (::xilinx::AIE::DeviceOp)

Define an AIE design targetting a complete device


Syntax:

```
operation ::= `AIE.device` `(` $device `)` regions attr-dict
```

This operation describes a design that executes on a particular AIEngine device.
It exists at the toplevel of a design; although currently it does not replace the
default toplevel module in MLIR, the intention is that this could be the case
in the future.

When using this operation, all resources in a physical device are available and
the design does not need to be concerned with other potential users of a physical
device.  In addition, within an `aie.device` operation, tile addresses are absolute
coordinates and are not intended to describe a relocatable design.  To describe
a portion of a device which may be relocatable, the intention would be to provide another
operation, for instance maybe `aie.segment`.
The design itself is described using a region of code contained by the device
operation.

Example:
```
aie.device(xcvc1902) {
  %tile = aie.tile(1, 1)
  %CORE = aie.core(%tile) { ... }
}
```

Traits: HasParent<ModuleOp>, IsolatedFromAbove, NoTerminator, SingleBlock, SymbolTable

Interfaces: AIETarget

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `device` | xilinx::AIE::AIEDeviceAttr | AIE Device

### `AIE.end` (::xilinx::AIE::EndOp)

end op


Syntax:

```
operation ::= `AIE.end` attr-dict
```

A generic terminator operation for AIE ops' regions.

Traits: Terminator

### `AIE.external_buffer` (::xilinx::AIE::ExternalBufferOp)

Declare a buffer in external memory


Syntax:

```
operation ::= `AIE.external_buffer` attr-dict `:` type($buffer)
```

This operation represents a buffer that exists in some physical
location in a device, most likely external memory. The exact address
of the external buffer is passed by the mlir_aie_external_set_addr()
and mlir_aie_external_set_addr_myBuffer_ functions in the associated 
.cpp test file. 

These external buffers are used within the buffer descriptors of a 
shimDMA, i.e., within AIE_DMABdOp operations of a AIE_ShimDMAOp.

Example:
```
  %buf = AIE.external_buffer : memref<256xi64>
```
This operation represents an external buffer.

#### Results:

| Result | Description |
| :----: | ----------- |
| `buffer` | memref of any type values

### `AIE.flow` (::xilinx::AIE::FlowOp)

A logical circuit-switched connection between cores


Syntax:

```
operation ::= `AIE.flow` `(` $source `,` $sourceBundle `:` $sourceChannel `,` $dest `,` $destBundle `:` $destChannel `)` attr-dict
```

The `aie.flow` operation represents a circuit switched connection between two endpoints, usually
`aie.tile` operations.  During routing, this is replaced by `aie.connect` operations which represent
the programmed connections inside a switchbox, along with `aie.wire` operations which represent
physical connections between switchboxes and other components.

Example:
```
  %00 = aie.tile(0, 0)
  %11 = aie.tile(1, 1)
  %01 = aie.tile(0, 1)
  aie.flow(%00, "DMA" : 0, %11, "Core" : 1)
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | index
| `dest` | index

### `AIE.getCascade` (::xilinx::AIE::GetCascadeOp)

An op to read from a cascading stream from a neighboring core


Syntax:

```
operation ::= `AIE.getCascade` `(` `)` attr-dict `:` type($cascadeValue)
```

An op to read from a cascading stream from a neighboring core.

Traits: HasParent<CoreOp>

#### Results:

| Result | Description |
| :----: | ----------- |
| `cascadeValue` | 384-bit integer

### `AIE.getStream` (::xilinx::AIE::GetStreamOp)

An op to read from a stream channel/port of a switchbox


Syntax:

```
operation ::= `AIE.getStream` `(` $channel `:` type($channel) `)` attr-dict `:` type($streamValue)
```

An op to read from a stream channel/port of a switchbox.

Traits: HasParent<CoreOp>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `channel` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `streamValue` | 32-bit float or 32-bit signless integer or 128-bit signless integer

### `AIE.lock` (::xilinx::AIE::LockOp)

Declare a physical lock


Syntax:

```
operation ::= `AIE.lock` `(` $tile (`,` $lockID^ )? `)` attr-dict
```

This operation creates a physical lock. For this operation the lockID variable is optional. 
However, if that is the case then the lockID must be assigned using the AIEAssignLockIDs pass. 

Example:
```
  %tile33 = AIE.tile(3, 3)
  %lck = AIE.lock(%tile33, 7)
```
This operation represents a lock that lives in the Memory module of Tile(3, 3) with a lockID of 7

Case when LockID is not assigned:
  Before AIEAssignLockIDs: %tile33 = AIE.tile(3)
  After AIEAssignLockIDs: %tile33 = AIE.tile(3, $assigned_value)

Interfaces: TileElement

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `lockID` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0
| `init` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.masterset` (::xilinx::AIE::MasterSetOp)

Packet switched input connection


Syntax:

```
operation ::= `AIE.masterset` `(` $destBundle `:` $destChannel `,` $amsels `)` attr-dict
```

A Packet switched connection inside a switchbox.
This operation specifies the configuration for a master port.

Example:
  %a0_m2 = AIE.amsel<0>(2)
  AIE.masterset("Core" : 0, %a0_m2)

The code will configure the master port <"Core" : 0> to use arbiter 0 with msel 2
(see AMSelOp for more details regarding AMSel)

In the current architecture, a master port can only be associated with one arbiter. However,
a master port can be activated by different msels from one arbiter

Example:
  %a1_0 = AIE.amsel<1>(0)
  %a1_1 = AIE.amsel<1>(1)
  %a2_3 = AIE.amsel<2>(3)

  AIE.masterset("West" : 2, %a1_0, %a2_3) // this is illegal, please don't do this
  AIE.masterset("West" : 3, %a1_0, %a1_1) // this is OK

Traits: HasParent<SwitchboxOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `amsels` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.mem` (::xilinx::AIE::MemOp)

Declare a memory op


Syntax:

```
operation ::= `AIE.mem` `(` $tile `)` regions attr-dict
```

This operation creates a Memory module that belongs to a tile.
The region of a MemOp is used to setup the DMAs and Block Descriptors.
See DMAStartOp and DMABdOp for more concrete examples on DMAs and Block Descriptors.

Example:
```
  m73 = AIE.mem(%t73) {
      %srcDma = AIE.dmaStart("S2MM", 0, ^bd0, ^end)
    ^bd0:
      AIE.useLock(%lock, "Acquire", 0)
      AIE.dmaBd(<%buf : memref<64xi16>, 0, 64>, 0)
      AIE.useLock(%lock, "Release", 1)
      AIE.nextBd ^bd0
    ^end:
      AIE.end
  }
```
Create the memory module for tile %t73 and setup one DMA channel and one Buffer Descriptor.

Traits: HasValidBDs, HasValidDMAChannels

Interfaces: CallableOpInterface, FlowEndPoint, TileElement

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.memTileDMA` (::xilinx::AIE::MemTileDMAOp)

Declare a memTileDMA op


Syntax:

```
operation ::= `AIE.memTileDMA` `(` $tile `)` regions attr-dict
```

This operation describes a DMA inside an AIE2 MemTile.
The region of the op is used to setup the DMAs and Block Descriptors.
See DMAStartOp and DMABdOp for more concrete examples on DMAs and Block Descriptors.

This operation is restricted to certain compatible tiles in AIE2 devices:
xcve2302: row 1
xcve2802: row 1 and 2

Example:
```
  m73 = AIE.memTileDMA(%t71) {
      %srcDma = AIE.dmaStart("S2MM", 0, ^bd0, ^end)
    ^bd0:
      AIE.useLock(%lock, "Acquire", 0)
      AIE.dmaBd(<%buf : memref<64xi16>, 0, 64>, 0)
      AIE.useLock(%lock, "Release", 1)
      AIE.nextBd ^bd0
    ^end:
      AIE.end
  }
```
Create a description for tile %t73 and setup one DMA channel and one Buffer Descriptor.

Traits: HasValidBDs, HasValidDMAChannels

Interfaces: CallableOpInterface, FlowEndPoint, TileElement

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.nextBd` (::xilinx::AIE::NextBDOp)

The next buffer descriptor


Syntax:

```
operation ::= `AIE.nextBd` $dest attr-dict
```

This operation terminates the basic block describing a buffer descriptor inside
a tile or shim DMA operation.  It references a single following buffer descriptor.
Note that unlike other terminators (like cf.br), canonicalization should not remove
the `nextBd` terminator, since it would result in invalid buffer descriptors.

Example:
```
  m73 = AIE.mem(%t73) {
      %srcDma = AIE.dmaStart("S2MM", 0, ^bd0, ^end)
    ^bd0:
      AIE.useLock(%lock, "Acquire", 0)
      AIE.dmaBd(<%buf : memref<64xi16>, 0, 64>, 0)
      AIE.useLock(%lock, "Release", 1)
      AIE.nextBd ^bd0
    ^end:
      AIE.end
  }
```

Traits: HasParent<MemOp, MemTileDMAOp, func::FuncOp, ShimDMAOp>, Terminator

#### Successors:

| Successor | Description |
| :-------: | ----------- |
| `dest` | any successor

### `AIE.objectFifo.acquire` (::xilinx::AIE::ObjectFifoAcquireOp)

Acquire operation to lock and return objects of an ObjectFifo


Syntax:

```
operation ::= `AIE.objectFifo.acquire` attr-dict `<` $port `>` `(` $fifo `:` type($fifo) `,` $size `)` `:` type($subview)
```

The `aie.objectFifo.acquire` operation first acquires the locks of the next given number 
of objects in the objectFifo. The mode it acquires the locks in is chosen based on the port 
(producer: acquire for write, consumer: acquire for read). Then, it returns a subview of 
the acquired objects which can be used to access them.

This operation is then converted by the AIEObjectFifoStatefulTransformPass into useLock operations on 
the locks of the objectFifo objects that will be acquired. Under the hood, the operation only performs
new acquires if necessary. For example, if two objects have been acquired in the past and none have yet
to be released by the same process, then performing another acquire operation on the same objectFifo 
within the same process of size two or less will not result in any new useLock operations (and for size 
greater than two, only (size - 2) useLock operations will be performed).

Example:
```
  %subview = AIE.objectFifo.acquire<Consume>(%objFifo : !AIE.objectFifo<memref<16xi32>>, 2) : !AIE.objectFifoSubview<memref<16xi32>>
```
This operation acquires the locks of the next two objects in objFifo from its consumer port and returns a subview of the acquired objects.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `port` | xilinx::AIE::ObjectFifoPortAttr | Ports of an object FIFO
| `size` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `fifo` | AIE objectFifo type

#### Results:

| Result | Description |
| :----: | ----------- |
| `subview` | AIE ObjectFifoSubview type

### `AIE.objectFifo.createObjectFifo` (::xilinx::AIE::ObjectFifoCreateOp)

Create a circular buffer or channel between two tiles


Syntax:

```
operation ::= `AIE.objectFifo.createObjectFifo` `(` $producerTile `,` `{` $consumerTiles `}` `,` $elemNumber `)` attr-dict `:` type($fifo)
```

The `aie.createObjectFifo` operation creates a circular buffer established between a producer and one or 
more consumers, which are `aie.tile` operations. The aie.createObjectFifo instantiates the given number of 
buffers (of given output type) and their locks in the Memory Module of the appropriate tile(s) after lowering, 
based on tile-adjacency. These elements represent the conceptual depth of the objectFifo.

For the producer and for each consumer, a different size (i.e., element number) can be specified. This will 
take effect in the case of consumers placed on tiles non-adjacent to the producer. Otherwise, the producer 
size will be applied. If a single size is specified, it will be applied to both producer and consumers.

This operation is then converted by the AIEObjectFifoStatefulTransformPass into buffers and their associated 
locks. The pass also establishes Flow and DMA operations between the producer and consumer tiles if they are
not adjacent.

Example:
```
  %objFifo = AIE.objectFifo.createObjectFifo(%tile12, {tile13, tile23}, 4) : !AIE.objectFifo<memref<16xi32>> 
```
This operation creates an objectFifo between %tile12, %tile13 and %tile23 of 4 elements, each a buffer of 16 32-bit integers.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `elemNumber` | ::mlir::Attribute | 32-bit signless integer attribute whose minimum value is 0 or array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `producerTile` | index
| `consumerTiles` | index

#### Results:

| Result | Description |
| :----: | ----------- |
| `fifo` | AIE objectFifo type

### `AIE.objectFifo.link` (::xilinx::AIE::ObjectFifoLinkOp)

Links two objectFifos through an intermediary tile's DMA


Syntax:

```
operation ::= `AIE.objectFifo.link` `(` `{` $fifoIns `}` `,` `{` $fifoOuts `}` `)` attr-dict `:` `(` `{` type($fifoIns) `}` `,` `{` type($fifoOuts) `}` `)`
```

The "aie.objectFifo.link" operation allows to mark two objectFifos as linked. This implies that the two objectFifos form
one dataflow movement which is split accross multiple objectFifos. Specifically, during the objectFifo lowering there will
be less memory elements generated at the link point as the two objectFifos can share.

The two objectFifos which are linked must have a link point (i.e., a shared AIE tile).
In L1, only objectFifos of same size may be linked. In L2, different sized objectFifos can be linked.

Example:
```
  %of_t70_t72 = AIE.objectFifo.createObjectFifo(%t70, {%t72}, 2) {sym_name = "of0"} : !AIE.objectFifo<memref<64xi16>>
  %of_t72_t74 = AIE.objectFifo.createObjectFifo(%t72, {%t74}, 2) {sym_name = "of1"} : !AIE.objectFifo<memref<64xi16>>
  AIE.objectFifo.link({%of_t70_t72}, {%of_t72_t74}) : ({!AIE.objectFifo<memref<64xi16>>}, {!AIE.objectFifo<memref<64xi16>>})
```
This operation links two objectFifos which have tile %t72 as a link point.

To achieve a broadcast pattern through the link tile, the output objectFifo should have a list of all the consumers tiles.
To achieve a distribute pattern from the link tile, there should be multiple output objectFifos in the LinkOp. In this case,
parts will be taken out of the input objectFifo's buffers based on the sizes of the output objectFifos, in the order they 
were given in the LinkOp.
The join pattern is the exact inverse of the distribute one.

Traits: AttrSizedOperandSegments

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `fifoIns` | AIE objectFifo type
| `fifoOuts` | AIE objectFifo type

### `AIE.objectFifo.registerExternalBuffers` (::xilinx::AIE::ObjectFifoRegisterExternalBuffersOp)

Registers external buffers to given object fifo shim tile(s) to use in the associated shim DMA(s)


Syntax:

```
operation ::= `AIE.objectFifo.registerExternalBuffers` attr-dict `(` $tile `,` $fifo `:` type($fifo) `,` `{` $externalBuffers `}` `)` `:` `(` type($externalBuffers) `)`
```

The `aie.objectFifo.registerExternalBuffers` operation is used to register one or multiple external buffers 
to the shim tile(s) used in an objectFifo creation. During the objectFifo lowering pass, shim DMAs that are
generated for those shim tiles will use the registered external buffers. This is currently done because 
external buffers typically have a different size than the AIE buffers which are used in the AIE tiles of the
same objectFifos.

Example:
```
  %of_t70_t73 = AIE.objectFifo.createObjectFifo(%t70, %t73, 2) : !AIE.objectFifo<memref<64xi16>>
  %buffer_in_0  = AIE.external_buffer : memref<512 x i16>
  %buffer_in_1  = AIE.external_buffer : memref<512 x i16>
  AIE.objectFifo.registerExternalBuffers(%t70, %of_t70_t73 : !AIE.objectFifo<memref<64xi16>>, {buffer_in_0, buffer_in_1}) : (memref<512 x i16>, memref<512 x i16>)
```
This operation registers external buffers %buffer_in_0 and %buffer_in_1 to use in the shimDMA of shimTile %t70.

Interfaces: TileElement

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index
| `fifo` | AIE objectFifo type
| `externalBuffers` | memref of any type values

### `AIE.objectFifo.registerProcess` (::xilinx::AIE::ObjectFifoRegisterProcessOp)

Operation that produces the acquire/release patterns for a process registered to an objectFifo


Syntax:

```
operation ::= `AIE.objectFifo.registerProcess` attr-dict `<` $port `>` `(` $fifo `:` type($fifo) `,` $acquirePatternTensor `:` type($acquirePatternTensor) `,` $releasePatternTensor `:` type($releasePatternTensor) `,` $callee `,` $length`)`
```

The `aie.registerProcess` operation allows the user to register a function to an objectFifo along with its 
acquire and release patterns. These patterns will be used to generate a sequence of acquires and releases
on the objectFifo elements. This generated sequence is often in the form of a for loop, however, in the case 
of cyclo-static patterns only the repetition of same number accesses and releases will generate a for loop. 
This may result in multiple for loops of different sizes being generated. If there is no repetition, then no 
loops will be generated.

Example:
```
  %length = arith.constant 10 : index
  %acquirePatternProducer = arith.constant dense<[1, 2, 2, 0]> : tensor<4xi32>
  %releasePatternProducer = arith.constant dense<[0, 1, 1, 2]> : tensor<4xi32>
  func @producer_work(%input : !AIE.objectFifoSubview<memref<16xi32>>) -> () { ... }

  AIE.objectFifo.registerProcess<Produce>(%objFifo : !AIE.objectFifo<memref<16xi32>>, %acquirePatternProducer : tensor<4xi32>, %releasePatternProducer : tensor<4xi32>, @producer_work, %length)
```
This operation registers function @producer_work and associated patterns to the produce end of %objFifo. 
@producer_work will be called with the subviews produced when acquiring elements from %objFifo following the acquire pattern.

If the input patterns are static (only one element) then the length of the produced for loop will be that of the input %length.
If the input patterns are cyclo-static then they must be of the same size.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `port` | xilinx::AIE::ObjectFifoPortAttr | Ports of an object FIFO
| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `fifo` | AIE objectFifo type
| `acquirePatternTensor` | tensor of 32-bit signless integer values
| `releasePatternTensor` | tensor of 32-bit signless integer values
| `length` | index

### `AIE.objectFifo.release` (::xilinx::AIE::ObjectFifoReleaseOp)

Release operation for object locks in an ObjectFifo


Syntax:

```
operation ::= `AIE.objectFifo.release` attr-dict `<` $port `>` `(` $fifo `:` type($fifo) `,` $size `)`
```

The `aie.objectFifo.release` operation releases the locks of the given number of objects 
in the objectFifo. The mode it releases the locks in is chosen based on the `port` 
(producer: release for read, consumer: release for write). 

This operation is then converted by the AIEObjectFifoStatefulTransformPass into useLock operations.

Example:
```
  AIE.objectFifo.release<Produce>(%objFifo : !AIE.objectFifo<memref<16xi32>>, 1)
```
This operation releases the lock of the next object in objFifo from producer port.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `port` | xilinx::AIE::ObjectFifoPortAttr | Ports of an object FIFO
| `size` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `fifo` | AIE objectFifo type

### `AIE.objectFifo.subview.access` (::xilinx::AIE::ObjectFifoSubviewAccessOp)

ObjectFifoSubview type accessor method


Syntax:

```
operation ::= `AIE.objectFifo.subview.access` $subview `[` $index `]` attr-dict `:` type($subview) `->` type($output)
```

Access the Nth element of a value of ObjectFifoSubview type.

Example:
```
  %subview = AIE.objectFifo.acquire<Produce>(%objFifo : !AIE.objectFifo<memref<16xi32>>, 3) : !AIE.objectFifoSubview<memref<16xi32>>
  %elem = AIE.objectFifo.subview.access %subview[0] : !AIE.objectFifoSubview<memref<16xi32>> -> memref<16xi32>
```
In this example, elem is the first object of the subview. Note that this may not correspond to the first element of 
the objectFifo if other acquire operations took place beforehand.


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `index` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `subview` | AIE ObjectFifoSubview type

#### Results:

| Result | Description |
| :----: | ----------- |
| `output` | memref of any type values

### `AIE.plio` (::xilinx::AIE::PLIOOp)

Declare an interface to the PL


Syntax:

```
operation ::= `AIE.plio` `(` $col `)` attr-dict
```

An interface to the PL.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `col` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.packet_dest` (::xilinx::AIE::PacketDestOp)

A destination port


Syntax:

```
operation ::= `AIE.packet_dest` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

A object representing the destination of a packet-switched flow. This must exist
within an [AIE.packet_flow](#aiepacketflow-aiepacketflowop) operation. The destination
Must be unique within a design.

See [AIE.packet_flow](#aiepacketflow-aiepacketflowop) for an example.

Traits: HasParent<PacketFlowOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `bundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

### `AIE.packet_flow` (::xilinx::AIE::PacketFlowOp)

Packet switched flow


Syntax:

```
operation ::= `AIE.packet_flow` `(` $ID `)` regions attr-dict
```

A logical packet-switched flow between tiles.  During place and
route, this is replaced by MasterSets and PacketRules inside
switchboxes.

Example:
```
  %01 = AIE.tile(0, 1)
  AIE.packet_flow(0x10) {
    AIE.packet_source<%01, "Core" : 0>
    AIE.packet_dest<%01, "Core" : 0>
  }
```

Traits: SingleBlockImplicitTerminator<EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `ID` | ::mlir::IntegerAttr | 8-bit signless integer attribute

### `AIE.rule` (::xilinx::AIE::PacketRuleOp)

Packet switched routing rule


Syntax:

```
operation ::= `AIE.rule` `(` $mask `,` $value `,` $amsel `)` attr-dict
```

This operation defines a matching rule and a destination for packet-switched
connections in a switchbox.  Routing is based on the ID field of packet arriving on the
matching port of the containing [AIE.packetRules](#aiepacketrules-aiepacketrulesop).
The ID is first bitwise-AND'd with the mask and then checked for equality with the given ID.
It is routed to arbiter and master set associated with the first matching entry.

Example:
  LUT ID  |  Mask     | ID          | Arbiter | Msel
  ---     | ---       | ---         | ---     | ---
  0       |  5'b11111 | 5'b00010    | 4       | 1
  1       |  5'b11011 | 5'b00001    | 3       | 2
  2       |           |             |         |
  3       |           |             |         |

If a packet flow that has an ID of 2, it will be directed to the arbiter 4 with msel 1,
If a packet flow that has an ID of 1 or 5, it will be directed to the arbiter 3 with msel 2,

We encapsulate the configuration table as follows:
Example:
```
  %a4_1 = AIE.amsel<4>(1)
  %a3_2 = AIE.amsel<3>(2)

  AIE.packetRules("Core" : 0) {
    AIE.rule(0x1F, 0x2, %a4_1)
    AIE.rule(0x1B, 0x1, %a3_2)
  }
```

Traits: HasParent<PacketRulesOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `mask` | ::mlir::IntegerAttr | 8-bit signless integer attribute
| `value` | ::mlir::IntegerAttr | 8-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `amsel` | index

### `AIE.packetrules` (::xilinx::AIE::PacketRulesOp)

Packet switched routing rules


Syntax:

```
operation ::= `AIE.packetrules` `(` $sourceBundle `:` $sourceChannel `)` regions attr-dict
```

This operation defines packet-switched routing configuration for packets entering a switchbox.
It references a port of the containing swithcbox, which be unique among other packetRules
operations and [AIE.connect]($aieconnect-aieconnectop) operations in the containing switchbox.
It contains a region of up to 4 [AIE.rule](#aierule-aiepacketruleop) operations.

See [AIE.rule](#aierule-aiepacketruleop) for an example.

Traits: SingleBlockImplicitTerminator<EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `sourceChannel` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

### `AIE.packet_source` (::xilinx::AIE::PacketSourceOp)

A sourceport


Syntax:

```
operation ::= `AIE.packet_source` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

A object representing the destination of a packet-switched flow. This must exist
within an [AIE.packet_flow](#aiepacketflow-aiepacketflowop) operation.

See [AIE.packet_flow](#aiepacketflow-aiepacketflowop) for an example.

Traits: HasParent<PacketFlowOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `bundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `channel` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

### `AIE.putCascade` (::xilinx::AIE::PutCascadeOp)

An op to write to a cascading stream from a neighboring core


Syntax:

```
operation ::= `AIE.putCascade` `(` $cascadeValue `:` type($cascadeValue) `)` attr-dict
```

An op to write to a cascading stream from a neighboring core.

Traits: HasParent<CoreOp>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `cascadeValue` | 384-bit integer

### `AIE.putStream` (::xilinx::AIE::PutStreamOp)

An op to write to a stream channel/port of a switchbox


Syntax:

```
operation ::= `AIE.putStream` `(` $streamValue `:` type($streamValue) `,` $channel `:` type($channel) `)` attr-dict
```

An op to write to a stream channel/port of a switchbox.

Traits: HasParent<CoreOp>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `channel` | integer
| `streamValue` | 32-bit float or 32-bit signless integer or 128-bit signless integer

### `AIE.shimDMAAllocation` (::xilinx::AIE::ShimDMAAllocationOp)

Runtime allocation information for a single shim DMA


Syntax:

```
operation ::= `AIE.shimDMAAllocation` `(` $sym_name `,` $channelDir `,` $channelIndex `,` $col `)` attr-dict
```

This op exists for cases where shimDMA configuration is performed outside of MLIR-AIE 
and hence there is no appropriate dmaStart operation to indicate which channel is being
used and on which column the shimDMA is. 

It contains attributes for the sym_name of an operation which generated the shim DMA, 
for the DMAChannelDir and channel index, and for the column of the shim tile to which 
the originating operation was mapped.

Example:
```
  %tile00 = AIE.tile(0, 0)
  %tile02 = AIE.tile(0, 2)
  %connect1 = AIE.objectFifo.createObjectFifo(%tile00, {%tile02}, 2) {sym_name = "of_in_0"} : !AIE.objectFifo<memref<64xi16>>
```
could produce the following allocation info (channel direction MM2S, channel index 1, and shim column 0):
```
  AIE.shimDMAAllocation("of_in_0", MM2S, 1, 0)
```

Traits: HasParent<ModuleOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sym_name` | ::mlir::StringAttr | string attribute
| `channelDir` | xilinx::AIE::DMAChannelDirAttr | DMA Channel direction
| `channelIndex` | ::mlir::IntegerAttr | 64-bit signless integer attribute
| `col` | ::mlir::IntegerAttr | 64-bit signless integer attribute

### `AIE.shimDMA` (::xilinx::AIE::ShimDMAOp)

Declare a DMA in the PL shim


Syntax:

```
operation ::= `AIE.shimDMA` `(` $tile `)` regions attr-dict
```

This operation creates a DMA that belongs to a shim tile.
The region of a ShimDMAOp is used to setup the DMAs and Block Descriptors.

Example:
```
  %buf = AIE.external_buffer : memref<256xi64>
  %lock1 = AIE.lock(%t70, 1)

  %dma = AIE.shimDMA(%t70) {
      AIE.dmaStart(MM2S, 0, ^bd0, ^end)
    ^bd0:
      AIE.useLock(%lock1, Acquire, 1)
      AIE.dmaBd(<%buf : memref<512 x i16>, 0, 512>, 0)
      AIE.useLock(%lock1, Release, 0)
      AIE.nextBd ^bd0
    ^end:
      AIE.end
  }
```
Create the shimDMA for tile %t70 and setup one DMA channel and one Buffer Descriptor.

Traits: HasValidBDs, HasValidDMAChannels

Interfaces: FlowEndPoint, TileElement

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.shimmux` (::xilinx::AIE::ShimMuxOp)

Declare a switch in the PL shim


Syntax:

```
operation ::= `AIE.shimmux` `(` $tile `)` regions attr-dict
```

This operation represents the additional interconnect that is part of a shim interface tile.
Like the `AIE.switchbox` operation, `AIE.shimMux` is configured
by code in its region, but can only contain connect operations

Example:
```
%tile = aie.tile(1, 1)
aie.shimmux(%tile) {
  aie.connect<"North" : 0, "DMA" : 1>
}
```

Traits: SingleBlockImplicitTerminator<EndOp>

Interfaces: Interconnect, TileElement

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.shimswitchbox` (::xilinx::AIE::ShimSwitchboxOp)

Declare a switch in the PL shim


Syntax:

```
operation ::= `AIE.shimswitchbox` `(` $col `)` regions attr-dict
```

A switch in the Shim.
AXI-Stream Master Ports AXI-Stream Slave Ports
6 Ports to North (Core Tile) 4 Ports from North (Core Tile)
4 Ports to West 4 Ports from West
4 Ports to East 4 Ports from East
6 Ports to South(DMA, NoC I/F, PL I/F) 8 Ports from South (DMA, NoC I/F, PL I/F)
2 Ports to FIFOs 2 Ports from FIFOs
1 Port for control packet for Shim register access
1 Port for response to access for Shim registers
1 Port for trace packet from Shim


Traits: SingleBlockImplicitTerminator<EndOp>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `col` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.switchbox` (::xilinx::AIE::SwitchboxOp)

Declare a switch


Syntax:

```
operation ::= `AIE.switchbox` `(` $tile `)` regions attr-dict
```

This operation represents the switchbox that is part of a tile.  A switchbox is configured
by code in its region, representing various connections

Example:
```
%tile = aie.tile(1, 1)
aie.switchbox(%tile) {
  aie.connect<"West" : 0, "Core" : 1>
}
```

Traits: SingleBlockImplicitTerminator<EndOp>

Interfaces: Interconnect, TileElement

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index

### `AIE.tile` (::xilinx::AIE::TileOp)

Declare an AIE tile


Syntax:

```
operation ::= `AIE.tile` `(` $col `,` $row `)` attr-dict
```

This operation creates an AIE tile in the AIE array. We specify what the column and the row of the tile.

A tile encompasses core module (CoreOp), memory module (MemOp), stream switch (SwitchboxOp),
memory buffer (BufferOp), and lock (LockOp).

A tile is a logical abstraction. We use a tile to establish an ownership of a hardware entity
to it.
Note that row 0 of the Tile array is different from other rows, since it models the shim interface between
the AIE array proper and the PL.  The South-West/Lower Right most core exists in Tile(0,1)

Interfaces: FlowEndPoint

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `col` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0
| `row` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 0

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index

### `AIE.useLock` (::xilinx::AIE::UseLockOp)

acquire/release lock op


Syntax:

```
operation ::= `AIE.useLock` `(` $lock `,` $action `,` $value ( `,` $blocking^ )? `)` attr-dict
```

This operation uses a lock. In AIE1, a lock can be acquired with a value,
or released with a value. This should be understood as a "blocking"
operation. In AIE2, locks are counting semaphores without inherent
acquired/release characteristic. This lock must appear in a parent op where
the tile can be determined (A CoreOp, a ShimDMAOp, a MemOp, or a
MemTileDMAOp).

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `action` | xilinx::AIE::LockActionAttr | lock acquire/release
| `blocking` | xilinx::AIE::LockBlockingAttr | lock operation is blocking

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lock` | index

### `AIE.wire` (::xilinx::AIE::WireOp)

A bundle of physical wires between components


Syntax:

```
operation ::= `AIE.wire` `(` $source `:` $sourceBundle `,` $dest `:` $destBundle `)` attr-dict
```

The `aie.wire` operation represents a physical set of connections between components in a Versal device.
Typically, these components are switches, represented by an `aie.switchbox` operation, and tiles,
represented by an [aie.tile](#aietile-aietileop) operation.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sourceBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires
| `destBundle` | xilinx::AIE::WireBundleAttr | Bundle of wires

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | index
| `dest` | index

## Type constraint definition

### AIE ObjectFifoSubview type



### AIE objectFifo type



